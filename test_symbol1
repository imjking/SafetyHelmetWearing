# -*- coding: utf-8 -*-
"""
Created on Mon Sep  2 19:22:50 2019

@author: czz
"""
import numpy as np
from gluoncv import data, utils
from mxnet import gluon

import mxnet as mx
import cv2
import time
import random
from matplotlib import pyplot as plt


def cv_plot_bbox1(img, bboxes, scores=None, labels=None, thresh=0.5,
                 class_names=None, colors=None,
                 absolute_coordinates=True, scale=1.0, linewidth=2):
    """Visualize bounding boxes with OpenCV.

    Parameters
    ----------
    img : numpy.ndarray or mxnet.nd.NDArray
        Image with shape `H, W, 3`.
    bboxes : numpy.ndarray or mxnet.nd.NDArray
        Bounding boxes with shape `N, 4`. Where `N` is the number of boxes.
    scores : numpy.ndarray or mxnet.nd.NDArray, optional
        Confidence scores of the provided `bboxes` with shape `N`.
    labels : numpy.ndarray or mxnet.nd.NDArray, optional
        Class labels of the provided `bboxes` with shape `N`.
    thresh : float, optional, default 0.5
        Display threshold if `scores` is provided. Scores with less than `thresh`
        will be ignored in display, this is visually more elegant if you have
        a large number of bounding boxes with very small scores.
    class_names : list of str, optional
        Description of parameter `class_names`.
    colors : dict, optional
        You can provide desired colors as {0: (255, 0, 0), 1:(0, 255, 0), ...}, otherwise
        random colors will be substituted.
    absolute_coordinates : bool
        If `True`, absolute coordinates will be considered, otherwise coordinates
        are interpreted as in range(0, 1).
    scale : float
        The scale of output image, which may affect the positions of boxes
    linewidth : int, optional, default 2
        Line thickness for bounding boxes.
        Use negative values to fill the bounding boxes.

    Returns
    -------
    numpy.ndarray
        The image with detected results.

    """

    # cv2 = try_import_cv2()

    if labels is not None and not len(bboxes) == len(labels):
        # print('The length of labels:', len(labels), 'mismatch bboxes:', len(bboxes))
        raise ValueError('The length of labels and bboxes mismatch, {} vs {}'.format(len(labels), len(bboxes)))

    if scores is not None and not len(bboxes) == len(scores):
        # print('The length of scores:', len(scores), 'mismatch bboxes:', len(bboxes))
        raise ValueError('The length of scores and bboxes mismatch, {} vs {}'.format(len(scores), len(bboxes)))


    if isinstance(img, mx.nd.NDArray):
        img = img.asnumpy()
    if isinstance(bboxes, mx.nd.NDArray):
        bboxes = bboxes.asnumpy()
    if isinstance(labels, mx.nd.NDArray):
        labels = labels.asnumpy()
    if isinstance(scores, mx.nd.NDArray):
        scores = scores.asnumpy()
    if len(bboxes) < 1:
        return img

    if not absolute_coordinates:
        # convert to absolute coordinates using image shape
        height = img.shape[0]
        width = img.shape[1]
        bboxes[:, (0, 2)] *= width
        bboxes[:, (1, 3)] *= height
    else:
        bboxes *= scale


    # use random colors if None is provided
    if colors is None:
        colors = dict()
    for i, bbox in enumerate(bboxes):
        if scores is not None and scores.flat[i] < thresh:
            continue
        if labels is not None and labels.flat[i] < 0:
            continue
        if labels is not None and labels.flat[i] == 0:
            continue
        cls_id = int(labels.flat[i]) if labels is not None else -1
        if cls_id not in colors:
            if class_names is not None:
                colors[cls_id] = plt.get_cmap('hsv')(cls_id / len(class_names))
            else:
                colors[cls_id] = (random.random(), random.random(), random.random())
        # xmin, ymin, xmax, ymax = [int(x) for x in bbox]
        xmin, ymin, xmax, ymax = int(bbox[0]), int(bbox[1]), int(bbox[2]), int(bbox[3])
        # bcolor = [x * 255 for x in colors[cls_id]]
        bcolor = []
        for xx in colors[cls_id]:
            bcolor.append(xx * 255)
        cv2.rectangle(img, (xmin, ymin), (xmax, ymax), bcolor, linewidth)

        if class_names is not None and cls_id < len(class_names):
            class_name = class_names[cls_id]
        else:
            class_name = str(cls_id) if cls_id >= 0 else ''
        score = '{:d}%'.format(int(scores.flat[i]*100)) if scores is not None else ''
        if class_name or score:
            y = ymin - 15 if ymin - 15 > 15 else ymin + 15
            cv2.putText(img, '{:s}{:s}'.format(class_name, score),
                        (xmin, y), cv2.FONT_HERSHEY_SIMPLEX, min(scale/2, 2),
                        bcolor, min(int(scale), 5), lineType=cv2.LINE_AA)

    return img


classes = ['hat', 'person']
# ctx = mx.gpu()
ctx = mx.cpu()

t0 = time.time()

frame = r'C:\Users\jiakang\Desktop\SafetyHelmetWearing\image\1.jpg'
# img = cv2.imread(frame)
x, img = data.transforms.presets.yolo.load_test(frame, short=416)
x = x.as_in_context(ctx)
net = gluon.SymbolBlock.imports(symbol_file=r'C:\Users\jiakang\Desktop\SafetyHelmetWearing\symbol/darknet53-symbol.json',  input_names=['data'], param_file=r'C:\Users\jiakang\Desktop\SafetyHelmetWearing\symbol/darknet53-0000.params', ctx=ctx)

# requirement: only need person box and its confidence score
box_ids, scores, bboxes = net(x)
# a = bboxes[0]
# aa = bboxes[0][0][0]
# aaa = aa.asscalar()

# bboxes1 = np.zeros(400).reshape(100, 4)
# scores1 = np.zeros(100).reshape(100, 1)
# box_ids1 = np.zeros(100).reshape(100, 1)
# for i in range(bboxes1.shape[0]):
#     for j in range(bboxes1.shape[1]):
#         bboxes1[i][j] = bboxes[0][i][j].asscalar()
# for ii in range(scores1.shape[0]):
#     for jj in range(scores1.shape[1]):
#         scores1[ii][jj] = scores[0][ii][jj].asscalar()
#         box_ids1[ii][jj] = box_ids[0][ii][jj].asscalar()
# ax = utils.viz.cv_plot_bbox1(img, bboxes1, scores1, box_ids1, class_names=classes, thresh=0.4)
# ax = utils.viz.cv_plot_bbox1(img, bboxes[0], scores[0], box_ids[0], class_names=classes, thresh=0.4)
ax = cv_plot_bbox1(img, bboxes[0], scores[0], box_ids[0], class_names=classes, thresh=0.4)
print(time.time() - t0, "seconds process time")

cv2.imshow('image', img[..., ::-1])
cv2.waitKey(0)
# cv2.imwrite(frame.split('.')[0] + '_result.jpg', img[...,::-1])
cv2.destroyAllWindows()
